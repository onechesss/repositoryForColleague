**Работа с Git:**

git config --global [user.name](http://user.name) "Practicum"

# вводите своё имя или ник латиницей и в кавычках


git config --global user.email [practicum@ya.ru](mailto:practicum@ya.ru)

# здесь нужно ввести свой реальный e-mail


git config --list

# вывели в окно командной строки список всех свойств конфига


«Репозиторий» — термин, который переводится с английского repository как «хранилище». Именно так программисты называют место, в котором хранятся все изменения проекта.

создание папки и назначение ее репозиторием

mkdir projects

cd projects

mkdir first-project-git

cd first-project-git

git init

Внутри папки проекта (`first-project-git`) появилась новая папка `.git`, в ней хранится вся служебная информация. А её содержимое можно посмотреть с помощью команды `ls .git`:


- `HEAD` — текстовый файл с указанием, куда ведёт ссылка `HEAD`. Можно посмотреть содержимое этого файла, не выходя из консоли с помощью `cat .git/HEAD`.
- `config` — текстовый файл с настройками репозитория.
- `description` — текстовый файл с описанием репозитория.
- `hooks` — папка с хуками Git. Хуки — это специальные скрипты, которые можно выполнять перед различными действиями с гитом.
- `info` — папка с дополнительной информации о репозитории. Например, там есть файл `exclude`, в котором можно задавать пути до файлов и папок, которые игнорируются гитом. Однако этот механизм неудобен и чаще всего мы используем `.gitignore` — файлы о которых мы поговорим попозже.
- `objects` — папка с объектами Git. Советуем заглядывать туда почаще после внесённых изменений, чтобы лучше понять, что было сделано.
- `refs` — папка со ссылками, сокращение от английского references — ссылки. Содержит в себе ветки и прочие ссылки, о которых мы говорили ранее.

Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку `.git`.

cd <папка с репозиторием> # перешли в папку

rm -rf .git # удалили подпапку .git

Разберём подробнее, что такое `-rf`:


- ключ `-r` (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым, с этим ключом мы уже знакомы;
- ключ `-f` (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».

Текущее состояние репозитория можно посмотреть с помощью команды `git status`:

git status

## Подготовка файла к сохранению


Создадим файл, используя уже известную команду `touch`:

touch hello.txt

Чтобы Git понял, что этот файл нужен для сохранения в новой версии, вводим `git add` и затем через пробел название файла:

git add hello.txt

Вы также можете добавить несколько файлов и подготовить их к сохранению «разом» с помощью `git add --all`:

touch todo.txt

touch readme.txt

...

git status # покажет список новых файлов в папке, но не в репозитории

git add --all # добавит все файлы к сохранению версии

Добавить все изменённые файлы можно без ключа `--all` через добавление текущей папки. В таком случае все файлы в ней тоже станут частью репозитория. Обратиться к текущей папке в терминале позволяет точка(`.`):

git add . # добавить всю текущую папку

git status

Теперь Git видит изменения, но ещё не «помнит» их как версию или ревизию. Файлы, которые отмечены зелёным, теперь отслеживаются и готовы к сохранению. Сохранения пока не произошло, потому что команда `git add` только запоминает текущее содержимое (контент) файла.

Само сохранение, или фиксацию состояния файлов, называют коммитом (от англ. commit — «совершать», «фиксировать»). «Сделать коммит» означает сохранить текущую версию файла или файлов.

Если провести аналогию, команду `git add` можно сравнить с добавлением товаров в корзину в интернет-магазине, а коммит — с оформлением и оплатой заказа.

Если сейчас отредактировать любой из «зелёных» файлов в папке `first-project-git`, он перейдёт в состояние modified (англ. «изменённый») и будет и в «зелёном», и в «красном» списках.

Например, откройте файл `todo.txt` в любом редакторе (подойдёт даже Xcode) и напишите в нём: `1. Пройти пару уроков Практикума`.

Сохраните изменения, а затем снова вызовите команду `git status` в консоли.

Файл `todo.txt` теперь есть и в «зелёном», и в «красном» списках:


- зелёным отмечена пустая версия файла — в таком виде он был во время последнего запуска команды `git add`;
- красным отмечена версия с текстом `1. Пройти пару уроков Практикума`.

Чтобы запомнить новое состояние файла, нужно снова ввести команду `git add` и передать ей в качестве параметра название файла, или ключ `--all` или текущую папку `.`.

git add todo.txt

## Делаем первый коммит


Сделать коммит можно командой `git commit` с ключом `-m`(от англ. **m**essage – сообщение), который присваивает коммиту название.

Обычно в таком сообщении содержится пояснение, что именно было изменено. Названия нужны, чтобы найти полезную версию и посмотреть состояние репозитория на момент этого коммита.

Сделайте свой первый коммит, откройте консоль и вызовите команду:

git commit -m "Мой первый коммит!"

После выполнения команды текущая версия файлов будет сохранена в репозитории под версией `"Мой первый коммит!"`. А в консоль выведется сообщение о добавленных изменениях.

Если вы случайно не напишете аргумент `-m` и просто введёте `git commit`, то git попросит ввести название коммита в редакторе по умолчанию. Иногда в таком случае открывается редактор `vim`. Вопрос, как выйти из него — часть фольклорного юмора программистов. Но откроем вам тайну: чтобы выйти из Vim, нужно ввести обязательно на английской раскладке `:q!`.

Вот что нужно знать про SSH-ключи:


- SSH (Secure Shell) — это протокол, который обеспечивает безопасное зашифрованное соединение между двумя устройствами через небезопасную сеть. Используется для безопасной передачи файлов.
- SSH-ключ — это специальный файл; он нужен, чтобы установить безопасное соединение с другим компьютером через интернет без ввода пароля.
- SSH-ключи состоят из двух частей. Одна находится у вас (это личный ключ, храните его в секрете), а вторая (публичный ключ) добавляется туда, куда вы хотите безопасно подключаться.

**Запомним!** Команда `git push` — вторая основная команда после `git commit`. Вы будете использовать её каждый раз, когда захотите опубликовать свои изменения в удалённом репозитории.

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/F8574035-AEF6-445E-9E79-E46E2DCBB840_2/MRHfxe5vUz1Uy6tNVcPgqbP399aJzFQ6xxWeeLoNRugz/Image.png)

**Запомним!** Команда `git clone` копирует проект в указанное место.

У Git есть и на это команда: `git pull`; а pull на английском — «тянуть».

Она противоположна команде `git push`: если первая выталкивала изменения в удалённый репозиторий, то `git pull` их вытягивает.

Команда `git pull` выполняет две основные операции:


- `git fetch`, которая скачивает изменения с удалённого репозитория,
- и `git merge`, которая объединяет эти изменения с вашей текущей рабочей версией.
- Перед выполнением `git pull` убедитесь, что ваша рабочая версия чиста, то есть все изменения зафиксированы: сделан commit.
- Иногда после выполнения `git pull` могут возникнуть конфликты слияния, если одни и те же части кода были изменены локально и в удалённом репозитории. В таком случае Git попросит вас разрешить эти конфликты перед тем как продолжить.

# Ветки и Pull Requests


git branch - просмотр текущей ветки

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/3109F6DA-2339-4874-8A74-0936DDBF408C_2/D8x4okLg7vyJyTCHvGmhoxIDS6yoaYzZdL84Vsg1VmQz/Image.png)

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/553255EB-5D8E-496F-83FD-44AF99929E75_2/PR5p4ovOxBnotzumPzxWde2YJxpqL7b6yRtGNI2XmcQz/Image.png)

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/92DD7F5B-43BE-4C0D-BE8F-1E32F468F411_2/A1gZjDbUkPOWU3VW59djvmLQ1sm8TPC3mJ8w4NJR4Pwz/Image.png)

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/A3F4C5D8-D8EE-4A6F-B380-69C44659A4FD_2/1GR8UMVZ43zt9YvhRrzFSZyndGyKrGxLdLfvENrwS7Qz/Image.png)

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/40580DAF-5C59-47AA-A50C-A98360AC316D_2/GREAUqelUl8IWoy2vkmddHMB1IoXTnZnbgfxLCRqHR0z/Image.png)

газанули в новую ветку и чекнули что газанули

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/D6F7969F-1989-4097-B425-8256D20EB377_2/BllKxg6UDM2nQa0mIdCDUYxjD9NHqhYyNqPCrTFN23oz/Image.png)

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/8C37AD84-A993-4F92-B7F1-8E9599BE60C3_2/QMiIGczpGC6twzslglzQiCr3EiyApxUjAxAfw6q33PYz/Image.png)

Представьте, что закончили разработку новой функциональности в отдельной ветке и готовы объединить её с главной — добавить свои изменения в основную версию проекта. Этот процесс называется слиянием веток или **мёрджем** (англ. merge — «сливать», «поглощать»).

Перед тем как начать слияние, нужно перейти в ветку, куда должны добавиться изменения. Обычно это главная ветка. Перейдите в неё и вызовите команду `git merge` с именем присоединяемой ветки `new_branch` в качестве параметра.

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/7AD09CDA-86C7-46C0-BC46-721C2A8B8DD3_2/J2O1guC4vWq5A4ckEbVCA1g8TWTTfQsqmii9ZLuxvHIz/Image.png)

![image](https://res.craft.do/user/full/87968a64-fded-40dd-298b-89b9a75bdd26/doc/BD76A2AF-E160-4153-8FF8-AA16A0502D0F/69D59C26-A1A3-48EF-A93C-E04AD1A302C2_2/66K6Y8dYB45nVN9fzo3dp7sJgcZvY8Td5iFqW7tluegz/Image.png)

GitHub предоставляет удобный механизм, чтобы обсуждать новые изменения в ветках — Pull Request (англ. «запрос на изменения»; буквально: «запрос на подтягивание»). Обычно его так и называют – пулл-реквест, или сокращают до ПР или PR.

**Алгоритм такой:**


1. Вы делаете задачу в своей ветке. Когда заканчиваете работу, создаёте пулл-реквест.
2. Ваши коллеги проверяют, что код выглядит аккуратно, логично и работа выполнена корректно. Они могут оставить комментарии, чтобы лучше понять решение или предложить, как сделать лучше. Этот процесс называется **code review** (англ. «рассмотрение кода») — или просто ревью.
3. После финального обсуждения вы сливаете свою ветку в основную.

**У каждого пулл-реквеста есть:**


- **Название** — краткое описание изменений. Например: «Добавлены главный экран и подсчёт статистики».
- **Описание** — развёрнутое описание изменений. Это поле заполнять необязательно, но желательно.
- **Исходная ветка** — та, в которой вы работали. Например, `merge-request`.
- **Целевая ветка** — основная ветка проекта, в которую хотите внести изменения.

Также у каждого пулл-реквеста может быть два исхода:


- **Merge** (англ. «соединить») — изменения приняты; код вливается в целевую ветку, пулл-реквест закрывается.
- **Close** (англ. «закрыть») — пулл-реквест закрывается без слияния изменений.

